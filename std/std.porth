macro NULL 0 end

macro nop end

macro true  1 cast(bool) end
macro false 0 cast(bool) end

// Standard streams
macro stdin  0 end
macro stdout 1 end
macro stderr 2 end

// Syscalls
macro SYS_read            0   end 
macro SYS_write           1   end 
macro SYS_open            2   end 
macro SYS_close           3   end 
macro SYS_fstat           5   end
macro SYS_mmap            9   end
macro SYS_exit            60  end
macro SYS_clock_nanosleep 230 end
macro SYS_openat          257 end
macro SYS_kcpm            312 end
macro SYS_finit_module    313 end

macro AT_FDCWD -100 end

macro O_RDONLY 0 end

macro CLOCK_MONOTONIC 1 end
macro TIMER_ABSTIME   1 end

macro MAP_PRIVATE 2 end
macro PROT_READ 1 end

// fstat stat structure
macro sizeof(stat) 144 end
macro stat.st_dev 0 + end
macro stat.st_ino 8 + end
macro stat.st_mode 24 + end
macro stat.st_nlink 16 + end
macro stat.st_uid 28 + end
macro stat.st_gid 32 + end
macro stat.st_rdev 40 + end
macro stat.st_size 48 + end
macro @stat.st_size stat.st_size @64 end // stat size accessor macro
macro stat.st_blksize 56 + end
macro stat.st_blocks 64 + end
macro stat.st_atim 72 + end
macro stat.st_mtim 88 + end
macro stat.st_ctim 104 + end
macro sizeof(stat.st_dev) 8 end
macro sizeof(stat.st_ino) 8 end
macro sizeof(stat.st_mode) 4 end
macro sizeof(stat.st_nlink) 8 end
macro sizeof(stat.st_uid) 4 end
macro sizeof(stat.st_gid) 4 end
macro sizeof(stat.st_rdev) 8 end
macro sizeof(stat.st_size) 8 end
macro sizeof(stat.st_blksize) 8 end
macro sizeof(stat.st_blocks) 8 end
macro sizeof(stat.st_atim) 16 end
macro sizeof(stat.st_mtim) 16 end
macro sizeof(stat.st_ctim) 16 end

// wrappers for syscalls
macro write  SYS_write                    syscall3 end
macro read   SYS_read                     syscall3 end
macro openat SYS_openat                   syscall3 end
macro fstat  SYS_fstat                    syscall2 end
macro close  SYS_close                    syscall1 end
macro exit   SYS_exit                     syscall1 drop end
macro mmap   SYS_mmap                     syscall6 end
macro clock_nanosleep SYS_clock_nanosleep syscall4 end

macro / divmod drop end
macro % divmod swap drop end
macro mod % end
macro div / end

macro nth_argv
    8 * argv + @64 cast(ptr)
end

// increments value a the pointer
macro inc64
    dup @64 1 + swap !64
end

macro dec64
    dup @64 1 - swap !64
end

// helpers

macro 2drop 
    drop drop
end

macro 2dup
    over over
end

macro todo
    "TODO: not implemented" stderr write
    1 exit
end

// Calcualte the length of the string and push it on to the stack
// the first element on the stack contains the length pf the string literal
// the second element on the stack contains the full length including \0
// NOTE: it counts event the new line \n
macro cstrlen
    dup
    while dup @8 0 != do 1 + end
    swap -
end

macro cstr-to-str
    dup cstrlen swap
end

// Comparing NULL terminated strings
macro cstreq
    while
        if over @8 0 != over @8 0 != and do
            over @8 over @8 =
        else
            false
        end
    do
        1 +
        swap 1 + 
    end
    @8 0 = swap @8 0 = and
end

macro fputs
    write drop
end

macro eputs
    stderr fputs
end

macro puts
    stdout fputs
end

// =========================================
//           STRING MANIPULATION
// =========================================

macro sizeof(Str) 16  end
macro Str.count  0 +  end
macro Str.data   8 +  end
macro @Str.count Str.count @64 end
macro @Str.data  Str.data  @64 cast(ptr) end
macro !Str.count Str.count !64 end
macro !Str.data  Str.data  !64  end

// "pushing the structure onto the stack"
macro @Str
    dup  @Str.count 
    swap @Str.data 
end

// poping the "string structure" of the stack
macro !Str // count data dst -
    dup Str.data rot swap !64
    !Str.count 
end

// chop a single char from the left side
macro str-chop-one-left // str --
    dup Str.count dec64
    Str.data inc64
end

// remove ' ' (space) characters while the input string starts with them
macro str-trim-left // input --
    while 
        if dup @Str.count 0 > do
            dup @Str.data @8 ' ' =
        else false end
    do
        dup str-chop-one-left
    end
    drop
end

macro str-chop-line // line input --
    // line->data = input->data
    2dup @Str.data swap !Str.data 
    // line->count = 0
    over 0 swap !Str.count
    while 
        if dup @Str.count 0 > do
            dup @Str.data @8 '\n' !=
        else false end
    do
        dup str-chop-one-left
        // increment count of the `line`
        swap dup Str.count inc64 swap
    end
    if dup @Str.count 0 > do
        dup str-chop-one-left
    end
    2drop
end

// TODO: merge chop word and chop line into a single macro
macro str-chop-word // word input --
    // word->data = input->data
    2dup @Str.data swap !Str.data 
    // word->count = 0
    over 0 swap !Str.count
    while 
        if dup @Str.count 0 > do
            dup @Str.data @8 ' ' !=
        else false end
    do
        dup str-chop-one-left
        // increment count of the `word`
        swap dup Str.count inc64 swap
    end
    if dup @Str.count 0 > do
        dup str-chop-one-left
    end
    2drop
end

// Deprecated Words
macro .64 swap !64 end
macro ,64 @64 end
macro ! !8 end
macro @ @8 end
macro . swap ! end
macro , @ end
