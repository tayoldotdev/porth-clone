include "std.porth"

macro MEM_CAPACITY    640000 end
macro SIM_STACK_CAP   1024   end

// operation codes
macro OP_PUSH_INT 0 end
macro OP_INTRINSIC 1 end
macro COUNT_OPZ 2 end

macro INTRINSIC_PLUS          0 end
macro INTRINSIC_MINUS         1 end
macro INTRINSIC_MUL           2 end
macro INTRINSIC_PRINT         3 end
macro INTRINSIC_DUP           4 end
macro INTRINSIC_DROP          5 end
macro COUNT_INTRINSICS        6 end

macro sizeof(Op)  16  end
macro Op.typ      0 + end
macro Op.operand  8 + end
macro @Op.typ     Op.typ @64 end
macro @Op.operand Op.operand @64 end
macro !Op.typ     Op.typ !64 end
macro !Op.operand Op.operand !64 end

macro OPS_CAP 1024 end

memory out_fd sizeof(u64) end
macro  @out_fd out_fd @64 end
macro  !out_fd out_fd !64 end

memory empty_envp sizeof(ptr) end
memory nasm_argv  sizeof(ptr) 4 * end

"/usr/bin/nasm"c nasm_argv 0 8 * + !64
"-felf64"c       nasm_argv 1 8 * + !64
"output.asm"c    nasm_argv 2 8 * + !64

memory ld_argv sizeof(ptr) 5 * end
"/usr/bin/ld"c ld_argv 0 8 * + !64
"-o"c          ld_argv 1 8 * + !64
"output"c      ld_argv 2 8 * + !64
"output.o"c    ld_argv 3 8 * + !64

memory output_argv sizeof(ptr) 2 * end
"./output"c output_argv 0 8 * + !64

memory wstatus sizeof(u64) end
proc cmd_echoed // argv
    "[CMD]" puts
    dup while dup @64 0 != do
        " " puts
        dup @64 cast(ptr) cstr-to-str puts
        8 +
    end drop
    "\n" puts

    fork

    dup 0 = if 
        drop
        dup @64 cast(ptr) empty_envp
        rot rot
        execve
        dup 0 < if 
            "[ERROR] could not exec external program\n" eputs
            1 exit
        end
    orelse dup 0 > if
        drop
        NULL 0 wstatus -1 wait4 drop
    else
        drop
        "[ERROR] could not fork a child\n" eputs
        1 exit
    end
    drop
end

// memory layout variables
memory file_path_cstr  sizeof(ptr)                 end
memory fd              sizeof(u64)                 end
memory statbuf         sizeof(stat)                end
memory content         sizeof(Str)                 end
memory line            sizeof(Str)                 end
memory word            sizeof(Str)                 end
memory line_number     sizeof(u64)                 end
memory line_start      sizeof(ptr)                 end
memory sim-stack-count sizeof(u64)                 end 
memory sim-stack       sizeof(u64) SIM_STACK_CAP * end
memory ops-count       sizeof(u64)                 end
memory ops             sizeof(Op)  OPS_CAP *       end

proc sim-stack-push // u64 --
    sim-stack-count @64 SIM_STACK_CAP >= if 
        here eputs ": ERROR: sim stack overflow in simulation mode\n" eputs 1 exit 
    end

    sim-stack sim-stack-count @64 8 * + !64

    sim-stack-count inc64
end

proc sim-stack-pop // -- u64
    sim-stack-count @64 0 = if  
        here eputs ": ERROR: sim stack underflow in simulation mode\n" eputs 1 exit
    end
    sim-stack-count dec64
    sim-stack sim-stack-count @64 8 * + @64
end

proc push-op // type operand --
    ops-count @64 sizeof(Op) * ops +
    dup rot swap !Op.operand
    !Op.typ 
    ops-count inc64
end

proc try_to_parse_word_as_int_or_fail_as_unknown_word // n1 s1 - ret
    0 0 while dup word @Str.count < do
      dup word @Str.data + @8
  
      dup is-digit lnot if 
        file_path_cstr @64 cast(ptr) cstr-to-str eputs
        ":" puts line_number @64 putd
        ":" puts word @Str.data cast(int) line_start @64 - 1 + putd
        ": ERROR: `" eputs word @Str eputs "` is an unknown word\n" eputs
        1 exit
      end
  
      '0' -
      rot 10 * +
      swap
      1 +
    end drop
end

proc print-op-typ
    COUNT_OPZ 2 != if 
        here eputs ": Assertion Failed: Exhaustive handling of Op types in print-op-typ\n" eputs
        1 exit
    end
    dup OP_PUSH_INT = if 
        "OP_PUSH_INT" puts
    orelse dup OP_INTRINSIC = if
        "OP_INTRINSIC" puts
    else
        here eputs ": unknown op type\n" eputs 
    end
    drop
end

proc print-opz // --
    0 while dup ops-count @64 < do
        // ptr
        dup sizeof(Op) * ops +
        "Type:    " puts dup @Op.typ print-op-typ "\n" puts 
        "Operand: " puts @Op.operand putd         "\n" puts
        "------------------\n" puts
        1 +
    end drop
end

proc simulate-opz
    0 while dup ops-count @64 < do
        // ptr type
        dup sizeof(Op) * ops +

        COUNT_OPZ 2 != if 
            here eputs ": Assertion Failed: Exhaustive handling of Op types in print-op-typ\n" eputs
            1 exit
        end

        // ptr
        dup @Op.typ OP_PUSH_INT = if 
            dup @Op.operand sim-stack-push
        orelse dup @Op.typ OP_INTRINSIC = if
            COUNT_INTRINSICS 6 != if 
                here eputs ": Assertion Failed: Exhaustive handling of intrinsics in print-op-typ\n" eputs
                1 exit
            end
            dup @Op.operand INTRINSIC_PLUS = if
                sim-stack-pop
                sim-stack-pop
                +
                sim-stack-push
            orelse dup @Op.operand INTRINSIC_MINUS = if
                sim-stack-pop
                sim-stack-pop
                swap
                -
                sim-stack-push
            orelse dup @Op.operand INTRINSIC_MUL = if
                sim-stack-pop
                sim-stack-pop
                *
                sim-stack-push
            orelse dup @Op.operand INTRINSIC_PRINT = if
                sim-stack-pop print
            orelse dup @Op.operand INTRINSIC_PRINT = if
                sim-stack-pop print
            orelse dup @Op.operand INTRINSIC_DUP = if
                sim-stack-pop
                dup
                sim-stack-push
                sim-stack-push
            orelse dup @Op.operand INTRINSIC_DROP = if
                sim-stack-pop
                drop
            else 
                here eputs ": unreachable\n" eputs 1 exit
                1 exit
            end 
        else 
            here eputs ": unreachable\n" eputs 1 exit
            1 exit
        end 
        drop
        1 +
    end drop
end

proc compile-opz // --
    420     // mode
    O_CREAT O_WRONLY or // flags
    "output.asm"c
    AT_FDCWD
    openat
    !out_fd

    @out_fd 0 < if
        "[ERROR] could not open `output.asm` \n" eputs
        1 exit
    end

    "BITS 64\n"                              @out_fd fputs
    "segment .text\n"                        @out_fd fputs
    "print:\n"                               @out_fd fputs
    "    mov     r9, -3689348814741910323\n" @out_fd fputs
    "    sub     rsp, 40\n"                  @out_fd fputs
    "    mov     BYTE [rsp+31], 10\n"        @out_fd fputs
    "    lea     rcx, [rsp+30]\n"            @out_fd fputs
    ".L2:\n"                                 @out_fd fputs
    "    mov     rax, rdi\n"                 @out_fd fputs
    "    lea     r8, [rsp+32]\n"             @out_fd fputs
    "    mul     r9\n"                       @out_fd fputs
    "    mov     rax, rdi\n"                 @out_fd fputs
    "    sub     r8, rcx\n"                  @out_fd fputs
    "    shr     rdx, 3\n"                   @out_fd fputs
    "    lea     rsi, [rdx+rdx*4]\n"         @out_fd fputs
    "    add     rsi, rsi\n"                 @out_fd fputs
    "    sub     rax, rsi\n"                 @out_fd fputs
    "    add     eax, 48\n"                  @out_fd fputs
    "    mov     BYTE [rcx], al\n"           @out_fd fputs
    "    mov     rax, rdi\n"                 @out_fd fputs
    "    mov     rdi, rdx\n"                 @out_fd fputs
    "    mov     rdx, rcx\n"                 @out_fd fputs
    "    sub     rcx, 1\n"                   @out_fd fputs
    "    cmp     rax, 9\n"                   @out_fd fputs
    "    ja      .L2\n"                      @out_fd fputs
    "    lea     rax, [rsp+32]\n"            @out_fd fputs
    "    mov     edi, 1\n"                   @out_fd fputs
    "    sub     rdx, rax\n"                 @out_fd fputs
    "    xor     eax, eax\n"                 @out_fd fputs
    "    lea     rsi, [rsp+32+rdx]\n"        @out_fd fputs
    "    mov     rdx, r8\n"                  @out_fd fputs
    "    mov     rax, 1\n"                   @out_fd fputs
    "    syscall\n"                          @out_fd fputs
    "    add     rsp, 40\n"                  @out_fd fputs
    "    ret\n"                              @out_fd fputs
    "global _start\n"                        @out_fd fputs
    "_start:\n"                              @out_fd fputs
    "    mov [args_ptr], rsp\n"              @out_fd fputs

    0 while dup ops-count @64 < do
        // ptr type
        dup sizeof(Op) * ops +

        COUNT_OPZ 2 != if
            here eputs ": Assertion Failed: Exhaustive handling of Op types in parse-file-path\n" eputs
            1 exit
        end

        // ptr
        dup @Op.typ OP_PUSH_INT = if
            ";;  -- push int " @out_fd fputs dup Op.operand @64 @out_fd fputd " --\n" @out_fd fputs
            "    mov rax, " @out_fd fputs dup Op.operand @64 @out_fd fputd "\n" @out_fd fputs
            "    push rax\n" @out_fd fputs
        orelse dup @Op.typ OP_INTRINSIC = if
            COUNT_INTRINSICS 6 != if
                here eputs ": Assertion Failed: Exhaustive handling of intrinsics in parse-file-path\n" eputs
                1 exit
            end
            dup @Op.operand INTRINSIC_PLUS = if
                ";;  -- plus --\n"   @out_fd fputs
                "    pop rax\n"      @out_fd fputs
                "    pop rbx\n"      @out_fd fputs
                "    add rax, rbx\n" @out_fd fputs
                "    push rax\n"     @out_fd fputs
            orelse dup @Op.operand INTRINSIC_MINUS = if
                ";;  -- minus --\n"  @out_fd fputs
                "    pop rax\n"      @out_fd fputs
                "    pop rbx\n"      @out_fd fputs
                "    sub rbx, rax\n" @out_fd fputs
                "    push rbx\n"     @out_fd fputs
            orelse dup @Op.operand INTRINSIC_MUL = if
                ";;  -- mul --\n"    @out_fd fputs
                "    pop rax\n"      @out_fd fputs
                "    pop rbx\n"      @out_fd fputs
                "    mul rbx\n"      @out_fd fputs
                "    push rax\n"     @out_fd fputs
            orelse dup @Op.operand INTRINSIC_PRINT = if
                ";;  -- print --\n"  @out_fd fputs
                "    pop rdi\n"      @out_fd fputs
                "    call print\n"   @out_fd fputs
            orelse dup @Op.operand INTRINSIC_DUP = if
                ";;  -- dup --\n"    @out_fd fputs
                "    pop rax\n"      @out_fd fputs
                "    push rax\n"     @out_fd fputs
                "    push rax\n"     @out_fd fputs
            orelse dup @Op.operand INTRINSIC_DROP = if
                ";;  -- drop --\n"   @out_fd fputs
                "    pop rax\n"      @out_fd fputs
            else
                here eputs ": unreachable\n" eputs 1 exit
                1 exit
            end
        else 
            here eputs ": unreachable\n" eputs 1 exit
            1 exit
        end
        drop
        1 +
    end drop
    "    mov rax, 60\n"  @out_fd fputs
    "    mov rdi, 0\n"   @out_fd fputs
    "    syscall\n"      @out_fd fputs
    "segment .bss\n"     @out_fd fputs
    "args_ptr: resq 1\n" @out_fd fputs
    "mem: resb "         @out_fd fputs MEM_CAPACITY @out_fd fputd "\n" @out_fd fputs

    @out_fd close drop

    nasm_argv cmd_echoed
    ld_argv cmd_echoed
    output_argv cmd_echoed
end

proc parse_file_path_cstr_into_opz
    // open the file
    0                             // mode
    O_RDONLY                      // flags
    file_path_cstr @64 cast(ptr)  // pathname
    AT_FDCWD                      // dirfd
    openat

    // validate successful opening of the file
    dup 0 < if
        "ERROR: could not open file `" eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "` not found\n" eputs
        1 exit
    end

    // save file descriptor to a global variable
    fd !64

    statbuf fd @64 fstat 0 < if
        "ERROR: could not determine the size of the file `" eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "`\n" eputs
        1 exit
    end

    // save the size of the file into the count of the content
    statbuf @stat.st_size content !Str.count 

    // memory map the file
    0                         // offset
    fd @64                    // fd
    MAP_PRIVATE               // flags
    PROT_READ                 // protc
    statbuf stat.st_size @64  // length
    NULL                      // addr
    mmap
    // save output of mmap onto `Str.data` of the `content` memory
    content !Str.data

    // validate success of the `mmap` syscall ~ validate memory mapping was successful
    content @Str.data cast(int) 0 < if
        "ERROR: could not memory map file `" eputs file_path_cstr @64 cast(ptr) cstr-to-str eputs "`\n" eputs
        1 exit
    end

    1 line_number !64
    while content @Str.count 0 > do
      '\n' line content str-chop-by-delim
      line @Str.data line_start !64
      while line @Str.count 0 > do
         line str-trim-left
         ' ' word line str-chop-by-delim
  
         COUNT_INTRINSICS 6 != if
           here eputs ": Assertion Failed: Exhaustive handling of intrinsics in parse-file-path\n" eputs
           1 exit
         end
  
         word @Str "+" streq if
           OP_INTRINSIC INTRINSIC_PLUS push-op
         orelse word @Str "-" streq if
           OP_INTRINSIC INTRINSIC_MINUS push-op
         orelse word @Str "*" streq if
           OP_INTRINSIC INTRINSIC_MUL push-op
         orelse word @Str "print" streq if
           OP_INTRINSIC INTRINSIC_PRINT push-op
         orelse word @Str "dup" streq if
           OP_INTRINSIC INTRINSIC_DUP push-op
         orelse word @Str "drop" streq if
           OP_INTRINSIC INTRINSIC_DROP push-op
         else
           OP_PUSH_INT try_to_parse_word_as_int_or_fail_as_unknown_word push-op
         end
      end
      line_number inc64
    end
    // TODO: parse_file_path does not clean up resources after itself
end

proc print_usage 
    dup "Usage: porth <SUBCOMMAND>\n" rot fputs
    dup "  SUBCOMMAND:\n" rot fputs
    dup "    sim <file>     Simulate the program\n" rot fputs
    dup "    com            Compile the program\n" rot fputs
    dup "    print          Print ops of the program\n" rot fputs
    dup "    help           Print this help to the stderr ane exit with 0 code\n" rot fputs
    drop
end
// TODO: parsing file is not implemented
// TODO: user cannot choose the mode (com vs sim) from command line args

// entrypoint of the program
proc main 
    argc 2 < if
        stderr print_usage
        here eputs ": ERROR: subcommands is not provided\n" eputs
        1 exit
    end

    1 nth_argv
    dup "com"c cstreq if
        argc 3 < if
            stderr print_usage
            "ERROR: No input file provided for the `com` subcommand" eputs
            1 exit
        end
        2 nth_argv file_path_cstr !64

        parse_file_path_cstr_into_opz

        compile-opz
    orelse dup "sim"c cstreq if
        argc 3 < if
            stderr print_usage
            "ERROR: No input file provided for the `sim` subcommand" eputs
            1 exit
        end
        2 nth_argv file_path_cstr !64

        parse_file_path_cstr_into_opz

        simulate-opz
    orelse dup "print"c cstreq if
        argc 3 < if
            stderr print_usage
            "ERROR: No input file provided for the `print` subcommand" eputs
            1 exit
        end
        
        2 nth_argv file_path_cstr !64

        parse_file_path_cstr_into_opz

        print-opz
    orelse dup "help"c cstreq if
        stdout print_usage
        0 exit
    else
        stderr print_usage
        "ERROR: unknown subcommand `" eputs dup dup cstrlen swap eputs "`\n" eputs
        1 exit
    end
    drop
end
main
