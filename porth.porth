include "std.porth"

macro PUTD_BUFFER_CAP 32     end
macro MEM_CAPACITY    640000 end
macro SIM_STACK_CAP   1024   end

// operation codes
macro OP_PUSH_INT 0 end
macro OP_PLUS     1 end
macro OP_PRINT    2 end

// struct Op {
//      type: u63,
//      operand: u64,
// }
macro Op.type    nop end
macro Op.operand 8 + end
macro sizeof(Op) 16  end

// memory layout
macro putd-buffer mem end

macro file_path_cstr putd-buffer PUTD_BUFFER_CAP + end
macro fd file_path_cstr 8 + end
macro statbuf fd 8 + end

macro content statbuf sizeof(stat) + end
macro line content sizeof(Str) + end
macro word line sizeof(Str) + end
macro streq_a word sizeof(Str) + end
macro streq_b streq_a sizeof(Str) + end
macro parse_int_a streq_b sizeof(Str) + end

macro sim-stack-count parse_int_a sizeof(Str) + end 
macro sim-stack sim-stack-count 8 + end
macro ops-count sim-stack SIM_STACK_CAP 8 * + end  
macro ops ops-count 8 + end

macro streq // n1 s1 n2 s2
    streq_a !Str
    streq_b !Str
    if streq_a @Str.count streq_b @Str.count = do
        0 while
            if dup streq_a @Str.count < do
                dup streq_a @Str.data + @8 
                over streq_b @Str.data + @8 
                =
            else false end
        do 1 + end
        streq_a @Str.count >= 
    else false end
end

macro sim-stack-push // u64 --
    if sim-stack-count @64 SIM_STACK_CAP >= do
        here eputs ": ERROR: sim stack overflow in simulation mode\n" eputs 1 exit 
    end

    sim-stack sim-stack-count @64 8 * + !64

    sim-stack-count inc64
end

macro sim-stack-pop // -- u64
    if sim-stack-count @64 0 = do 
        here eputs ": ERROR: sim stack underflow in simulation mode\n" eputs 1 exit
    end
    sim-stack-count dec64
    sim-stack sim-stack-count @64 8 * + @64
end

macro push-op // type operand --
    ops-count @64 sizeof(Op) * ops +
    dup Op.operand rot swap !64
    Op.type !64
    ops-count inc64
end

macro putd // u64 --
    if dup 0 = do
      "0" puts
    else
      putd-buffer PUTD_BUFFER_CAP +
      while over 0 > do
        1 - dup rot
        10 divmod
        rot swap '0' + . swap
      end
  
      dup
      putd-buffer PUTD_BUFFER_CAP + swap - swap puts
    end
    drop
end

macro parse_int // n1 s1 - 
    parse_int_a !Str
    0 0 while dup parse_int_a @Str.count < do
        dup parse_int_a @Str.data + @8 '0' -
        rot 10 * +
        swap
        1 +
    end drop
end

macro print-opz // --
    0 while dup ops-count @64 < do
        // ptr
        dup sizeof(Op) * ops +
        "Type:    " puts dup Op.type @64 print 
        "Operand: " puts Op.operand @64 print
        "------------------\n" puts
        1 +
    end drop
end

macro simulate-opz
    0 while dup ops-count @64 < do
        // ptr type
        dup sizeof(Op) * ops +

        // ptr
        if dup Op.type @64 OP_PUSH_INT = do
            dup Op.operand @64 sim-stack-push
        else if dup Op.type @64 OP_PLUS = do
            sim-stack-pop
            sim-stack-pop
            +
            sim-stack-push
        else if dup Op.type @64 OP_PRINT = do
            sim-stack-pop print
        else 
            here eputs ": unreachable\n" eputs 1 exit
        end end end // TOOD: introduce a better construction to avoid this mess
        drop
        1 +
    end drop
end

// TODO: porth.porth does not run nasm and ld as external commands to finish off the process of compilation
macro compile-opz // --
    "BITS 64\n" puts
    "segment .text\n" puts
    "print:\n" puts
    "    mov     r9, -3689348814741910323\n" puts
    "    sub     rsp, 40\n" puts
    "    mov     BYTE [rsp+31], 10\n" puts
    "    lea     rcx, [rsp+30]\n" puts
    ".L2:\n" puts
    "    mov     rax, rdi\n" puts
    "    lea     r8, [rsp+32]\n" puts
    "    mul     r9\n" puts
    "    mov     rax, rdi\n" puts
    "    sub     r8, rcx\n" puts
    "    shr     rdx, 3\n" puts
    "    lea     rsi, [rdx+rdx*4]\n" puts
    "    add     rsi, rsi\n" puts
    "    sub     rax, rsi\n" puts
    "    add     eax, 48\n" puts
    "    mov     BYTE [rcx], al\n" puts
    "    mov     rax, rdi\n" puts
    "    mov     rdi, rdx\n" puts
    "    mov     rdx, rcx\n" puts
    "    sub     rcx, 1\n" puts
    "    cmp     rax, 9\n" puts
    "    ja      .L2\n" puts
    "    lea     rax, [rsp+32]\n" puts
    "    mov     edi, 1\n" puts
    "    sub     rdx, rax\n" puts
    "    xor     eax, eax\n" puts
    "    lea     rsi, [rsp+32+rdx]\n" puts
    "    mov     rdx, r8\n" puts
    "    mov     rax, 1\n" puts
    "    syscall\n" puts
    "    add     rsp, 40\n" puts
    "    ret\n" puts
    "global _start\n" puts
    "_start:\n" puts
    "    mov [args_ptr], rsp\n" puts

    0 while dup ops-count @64 < do
        // ptr type
        dup sizeof(Op) * ops +

        // ptr
        if dup Op.type @64 OP_PUSH_INT = do
            ";;  -- push int " puts dup Op.operand @64 putd " --\n" puts
            "    mov rax, " puts dup Op.operand @64 putd "\n" puts
            "    push rax\n" puts
        elif dup Op.type @64 OP_PLUS = do
            ";;  -- plus --\n" puts
            "    pop rax\n" puts
            "    pop rbx\n" puts
            "    add rax, rbx\n" puts
            "    push rax\n" puts
        elif dup Op.type @64 OP_PRINT = do
            ";;  -- print --\n" puts
            "    pop rdi\n" puts
            "    call print\n" puts
        else 
            here eputs ": unreachable\n" eputs 1 exit
        end
        drop
        1 +
    end drop
    "    mov rax, 60\n" puts
    "    mov rdi, 0\n" puts
    "    syscall\n" puts
    "segment .bss\n" puts
    "args_ptr: resq 1\n" puts
    "mem: resb " puts MEM_CAPACITY putd "\n" puts
end

macro parse_file_path
    // open the file
    O_RDONLY   // flags
    file_path_cstr @64 cast(ptr) // pathname
    AT_FDCWD   // dirfd
    openat

    // validate successful opening of the file
    if dup 0 < do
        "ERROR: could not open file `" eputs file_path_cstr @64 cast(ptr) cstr-to-pstr eputs "` not found\n" eputs
        1 exit
    end

    // save file descriptor to a global variable
    fd !64

    if statbuf fd @64 fstat 0 < do
        "ERROR: could not determine the size of the file `" eputs file_path_cstr @64 cast(ptr) cstr-to-pstr eputs "`\n" eputs
        1 exit
    end

    // save the size of the file into the count of the content
    statbuf @stat.st_size content !Str.count 

    // memory map the file
    0                         // offset
    fd @64                    // fd
    MAP_PRIVATE               // flags
    PROT_READ                 // protc
    statbuf stat.st_size @64  // length
    NULL                      // addr
    mmap
    // save output of mmap onto `Str.data` of the `content` memory
    content !Str.data

    // validate success of the `mmap` syscall ~ validate memory mapping was successful
    if content @Str.data cast(int) 0 < do
        "ERROR: could not memory map file `" eputs file_path_cstr @64 cast(ptr) cstr-to-pstr eputs "`\n" eputs
        1 exit
    end

    while content Str.count @64 0 > do
        line content str-chop-line
        while line Str.count @64 0 > do
            line str-trim-left
            word line str-chop-word
            if word @Str "+" streq do
                OP_PLUS 0 push-op
            elif word @Str "print" streq do
                OP_PRINT 0 push-op
            else
                OP_PUSH_INT word @Str parse_int push-op
            end
        end
    end
end

macro print_usage 
    dup "Usage: porth <SUBCOMMAND>\n" rot fputs
    dup "  SUBCOMMAND:\n" rot fputs
    dup "    sim <file>     Simulate the program\n" rot fputs
    dup "    com            Compile the program\n" rot fputs
    dup "    print          Print ops of the program\n" rot fputs
    dup "    help           Print this help to the stderr ane exit with 0 code\n" rot fputs
    drop
end
// TODO: parsing file is not implemented
// TODO: user cannot choose the mode (com vs sim) from command line args

// entrypoint of the program
macro main 
    if argc 2 < do
        stderr print_usage
        here eputs ": ERROR: subcommands is not provided\n" eputs
        1 exit
    end

    1 nth_argv
    if dup "com"c cstreq do
        if argc 3 < do
            stderr print_usage
            "ERROR: No input file provided for the `com` subcommand" eputs
            1 exit
        end
        2 nth_argv file_path_cstr !64

        parse_file_path

        compile-opz
    elif dup "sim"c cstreq do
        if argc 3 < do
            stderr print_usage
            "ERROR: No input file provided for the `sim` subcommand" eputs
            1 exit
        end
        2 nth_argv file_path_cstr !64

        parse_file_path

        simulate-opz
    elif dup "print"c cstreq do
        print-opz
    elif dup "help"c cstreq do
        stdout print_usage
        0 exit
    else
        stderr print_usage
        "ERROR: unknown subcommand `" eputs dup dup cstrlen swap eputs "`\n" eputs
        1 exit
    end
    drop
end
main
