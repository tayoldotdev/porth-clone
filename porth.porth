include "std.porth"

const MEM_CAPACITY    640000 end
const SIM_STACK_CAP   1024   end

// operation codes
const OP_PUSH_INT  1 offset end
const OP_IF        1 offset end
const OP_ELSE      1 offset end
const OP_END       1 offset end
const OP_INTRINSIC 1 offset end
const COUNT_OPZ       reset end

const INTRINSIC_PLUS      1 offset end
const INTRINSIC_MINUS     1 offset end
const INTRINSIC_MUL       1 offset end
const INTRINSIC_DIVMOD    1 offset end
const INTRINSIC_EQ        1 offset end
const INTRINSIC_GT        1 offset end
const INTRINSIC_LT        1 offset end
const INTRINSIC_GE        1 offset end
const INTRINSIC_LE        1 offset end
const INTRINSIC_NE        1 offset end
const INTRINSIC_SHR       1 offset end
const INTRINSIC_SHL       1 offset end
const INTRINSIC_OR        1 offset end
const INTRINSIC_AND       1 offset end
const INTRINSIC_NOT       1 offset end
const INTRINSIC_PRINT     1 offset end
const INTRINSIC_DUP       1 offset end
const INTRINSIC_SWAP      1 offset end
const INTRINSIC_DROP      1 offset end
const INTRINSIC_OVER      1 offset end
const INTRINSIC_ROT       1 offset end
const INTRINSIC_LOAD8     1 offset end
const INTRINSIC_LOAD16    1 offset end
const INTRINSIC_LOAD32    1 offset end
const INTRINSIC_LOAD64    1 offset end
const INTRINSIC_STORE8    1 offset end
const INTRINSIC_STORE16   1 offset end
const INTRINSIC_STORE32   1 offset end
const INTRINSIC_STORE64   1 offset end
const INTRINSIC_CAST_PTR  1 offset end
const INTRINSIC_CAST_INT  1 offset end
const INTRINSIC_CAST_BOOL 1 offset end
const INTRINSIC_ARGC      1 offset end
const INTRINSIC_ARGV      1 offset end
const INTRINSIC_HERE      1 offset end
const INTRINSIC_SYSCALL0  1 offset end
const INTRINSIC_SYSCALL1  1 offset end
const INTRINSIC_SYSCALL2  1 offset end
const INTRINSIC_SYSCALL3  1 offset end
const INTRINSIC_SYSCALL4  1 offset end
const INTRINSIC_SYSCALL5  1 offset end
const INTRINSIC_SYSCALL6  1 offset end
const COUNT_INTRINSICS       reset end

const OPS_CAP     1024           end
const sizeof(Op)  16             end
proc Op.typ      0 +            end
proc Op.operand  8 +            end
proc @Op.typ     Op.typ @64     end
proc @Op.operand Op.operand @64 end
proc !Op.typ     Op.typ !64     end
proc !Op.operand Op.operand !64 end

proc cmd_echoed // argv
    memory wstatus sizeof(u64) end
    memory empty-envp sizeof(ptr) end
    0 empty-envp !64

    "[CMD]" puts
    dup while dup @64 0 != do
        " " puts
        dup @ptr cstr-to-str puts
        8 +
    end drop
    "\n" puts

    fork

    dup 0 = if 
        drop
        dup @ptr empty-envp
        rot rot
        execve
        dup 0 < if 
            "[ERROR] could not exec external program\n" eputs
            1 exit
        end
    else dup 0 > if*
        drop
        NULL 0 wstatus -1 wait4 drop
    else
        drop
        "[ERROR] could not fork a child\n" eputs
        1 exit
    end
    drop
end

// memory layout variables
memory sim-stack-count   sizeof(u64)                 end 
memory sim-stack         sizeof(u64) SIM_STACK_CAP * end
memory ops-count         sizeof(u64)                 end
proc  @ops-count        ops-count   @64             end
memory ops               sizeof(Op)  OPS_CAP *       end

proc sim-stack-push // type operand --
    cast(int)
    sim-stack-count @64 SIM_STACK_CAP >= if 
        here eputs ": ERROR: sim stack overflow in simulation mode\n" eputs 1 exit 
    end
    sim-stack sim-stack-count @64 8 * + !64
    sim-stack-count inc64
end

proc sim-stack-pop // -- u64
    sim-stack-count @64 0 = if  
        here eputs ": ERROR: sim stack underflow in simulation mode\n" eputs 1 exit
    end
    sim-stack-count dec64
    sim-stack sim-stack-count @64 8 * + @64
end

proc push-op // type operand --
    @ops-count OPS_CAP >= if
        here eputs ": ERROR: ops overflow\n" eputs
        1 exit
    end
    @ops-count sizeof(Op) * ops +
    dup rot swap !Op.operand
    !Op.typ 
    ops-count inc64
end

proc print-op-typ
    assert
        "Exhaustive handling of Op types in print-op-typ"
        COUNT_OPZ 5 = 
    end

    dup OP_PUSH_INT = if 
        "OP_PUSH_INT" puts
    else dup OP_IF = if*
        "OP_IF" puts
    else dup OP_END = if*
        "OP_END" puts
    else dup OP_INTRINSIC = if*
        "OP_INTRINSIC" puts
    else
        here eputs ": unknown op type\n" eputs 
    end
    drop
end

proc print-opz // --
    0 while dup @ops-count < do
        // ptr
        dup sizeof(Op) * ops +
        "Type:    " puts dup @Op.typ print-op-typ "\n" puts 
        "Operand: " puts @Op.operand putu         "\n" puts
        "------------------\n" puts
        1 +
    end drop
end

proc simulate-opz // --

    memory sim-ip sizeof(u64) end
    memory sim-op sizeof(Op) end

    0 sim-ip !64
    while sim-ip @64 @ops-count < do
        sizeof(Op)
        sim-ip @64 sizeof(Op) * ops +
        sim-op
        memcpy

        assert
            "Exhaustive handling of Op types in simulate-opz"
            COUNT_OPZ 5 =  
        end

        // ptr
        sim-op @Op.typ OP_PUSH_INT = if 
            sim-op @Op.operand sim-stack-push
            sim-ip inc64
        else sim-op @Op.typ OP_IF = if*
            sim-stack-pop cast(bool) if
                sim-ip inc64
            else
                sim-op @Op.operand sim-ip !64
            end
        else sim-op @Op.typ OP_ELSE = if*
            sim-op @Op.operand sim-ip !64
        else sim-op @Op.typ OP_END = if*
            sim-op @Op.operand sim-ip !64
        else sim-op @Op.typ OP_INTRINSIC = if*
            assert
                "Exhaustive handling of intrinsics in simulate-opz"
                COUNT_INTRINSICS 42 =
            end
            sim-op @Op.operand INTRINSIC_PLUS = if
                sim-stack-pop
                sim-stack-pop
                +
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_MINUS = if*
                sim-stack-pop
                sim-stack-pop
                swap
                -
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_MUL = if*
                sim-stack-pop
                sim-stack-pop
                *
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_DIVMOD = if*
                sim-stack-pop
                sim-stack-pop
                swap
                divmod
                sim-stack-push
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_EQ = if*
                sim-stack-pop
                sim-stack-pop
                =
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_GT = if*
                sim-stack-pop
                sim-stack-pop
                swap
                >
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_LT = if*
                sim-stack-pop
                sim-stack-pop
                swap
                <
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_GE = if*
                sim-stack-pop
                sim-stack-pop
                swap
                >=
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_LE = if*
                sim-stack-pop
                sim-stack-pop
                swap
                <=
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_NE = if*
                sim-stack-pop
                sim-stack-pop
                !=
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_SHR = if*
                sim-stack-pop
                sim-stack-pop
                swap
                shr
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_SHL = if*
                sim-stack-pop
                sim-stack-pop
                swap
                shl
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_OR = if*
                sim-stack-pop
                sim-stack-pop
                or
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_AND = if*
                sim-stack-pop
                sim-stack-pop
                and
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_NOT = if*
                sim-stack-pop
                not
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_PRINT = if*
                sim-stack-pop
                print
            else sim-op @Op.operand INTRINSIC_DUP = if*
                sim-stack-pop
                sim-op
                sim-stack-push
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_SWAP = if*
                sim-stack-pop
                sim-stack-pop 
                swap
                sim-stack-push
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_DROP = if*
                sim-stack-pop
                drop
            else sim-op @Op.operand INTRINSIC_OVER = if*
                sim-stack-pop
                sim-stack-pop
                dup
                sim-stack-push
                swap
                sim-stack-push
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_ROT = if*
                sim-stack-pop
                sim-stack-pop
                sim-stack-pop
                swap
                sim-stack-push
                swap
                sim-stack-push
                sim-stack-push
            else sim-op @Op.operand INTRINSIC_LOAD8 = if*
                here puts ": TODO: @8 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_STORE8 = if*
                here puts ": TODO: !8 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_LOAD16 = if*
                here puts ": TODO: @16 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_STORE16 = if*
                here puts ": TODO: !16 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_LOAD32 = if*
                here puts ": TODO: @32 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_STORE32 = if*
                here puts ": TODO: !32 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_LOAD64 = if*
                here puts ": TODO: @64 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_STORE64 = if*
                here puts ": TODO: !64 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_ARGC = if*
                here puts ": TODO: argc is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_ARGV = if*
                here puts ": TODO: argv is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_HERE = if*
                here puts ": TODO: here is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_CAST_PTR = if*
            else sim-op @Op.operand INTRINSIC_CAST_INT = if*
            else sim-op @Op.operand INTRINSIC_CAST_BOOL = if*
            else sim-op @Op.operand INTRINSIC_SYSCALL0 = if*
                here puts ": TODO: syscall0 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_SYSCALL1 = if*
                here puts ": TODO: syscall1 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_SYSCALL2 = if*
                here puts ": TODO: syscall2 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_SYSCALL3 = if*
                here puts ": TODO: syscall3 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_SYSCALL4 = if*
                here puts ": TODO: syscall4 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_SYSCALL5 = if*
                here puts ": TODO: syscall5 is not implemented" eputs
            else sim-op @Op.operand INTRINSIC_SYSCALL6 = if*
                here puts ": TODO: syscall6 is not implemented" eputs
            else 
                here eputs ": unreachable\n" eputs 1 exit
                1 exit
            end 
            sim-ip inc64
        else 
            here eputs ": unreachable\n" eputs 1 exit
            1 exit
        end 
    end 
end

proc compile-opz // --
    "[INFO] Generating output.asm\n" puts

    memory out-fd sizeof(u64) end

    420     // mode
    O_CREAT O_WRONLY or // flags
    "output.asm"c
    AT_FDCWD
    openat
    out-fd !64

    out-fd @64 0 < if
        "[ERROR] could not open `output.asm` \n" eputs
        1 exit
    end

    "BITS 64\n"                              out-fd @64 fputs
    "segment .text\n"                        out-fd @64 fputs
    "print:\n"                               out-fd @64 fputs
    "    mov     r9, -3689348814741910323\n" out-fd @64 fputs
    "    sub     rsp, 40\n"                  out-fd @64 fputs
    "    mov     BYTE [rsp+31], 10\n"        out-fd @64 fputs
    "    lea     rcx, [rsp+30]\n"            out-fd @64 fputs
    ".L2:\n"                                 out-fd @64 fputs
    "    mov     rax, rdi\n"                 out-fd @64 fputs
    "    lea     r8, [rsp+32]\n"             out-fd @64 fputs
    "    mul     r9\n"                       out-fd @64 fputs
    "    mov     rax, rdi\n"                 out-fd @64 fputs
    "    sub     r8, rcx\n"                  out-fd @64 fputs
    "    shr     rdx, 3\n"                   out-fd @64 fputs
    "    lea     rsi, [rdx+rdx*4]\n"         out-fd @64 fputs
    "    add     rsi, rsi\n"                 out-fd @64 fputs
    "    sub     rax, rsi\n"                 out-fd @64 fputs
    "    add     eax, 48\n"                  out-fd @64 fputs
    "    mov     BYTE [rcx], al\n"           out-fd @64 fputs
    "    mov     rax, rdi\n"                 out-fd @64 fputs
    "    mov     rdi, rdx\n"                 out-fd @64 fputs
    "    mov     rdx, rcx\n"                 out-fd @64 fputs
    "    sub     rcx, 1\n"                   out-fd @64 fputs
    "    cmp     rax, 9\n"                   out-fd @64 fputs
    "    ja      .L2\n"                      out-fd @64 fputs
    "    lea     rax, [rsp+32]\n"            out-fd @64 fputs
    "    mov     edi, 1\n"                   out-fd @64 fputs
    "    sub     rdx, rax\n"                 out-fd @64 fputs
    "    xor     eax, eax\n"                 out-fd @64 fputs
    "    lea     rsi, [rsp+32+rdx]\n"        out-fd @64 fputs
    "    mov     rdx, r8\n"                  out-fd @64 fputs
    "    mov     rax, 1\n"                   out-fd @64 fputs
    "    syscall\n"                          out-fd @64 fputs
    "    add     rsp, 40\n"                  out-fd @64 fputs
    "    ret\n"                              out-fd @64 fputs
    "global _start\n"                        out-fd @64 fputs
    "_start:\n"                              out-fd @64 fputs
    "    mov [args_ptr], rsp\n"              out-fd @64 fputs

    0 while dup @ops-count < do
        // ptr type
        dup sizeof(Op) * ops +

        assert
            "Exhaustive handling of Op types in parse-file-path"
            COUNT_OPZ 5 =
        end

        "addr_" out-fd @64 fputs
        over    out-fd @64 fputu
        ":\n"   out-fd @64 fputs
        // ptr
        dup @Op.typ OP_PUSH_INT = if
            ";;  -- push int "           out-fd @64 fputs dup Op.operand @64 out-fd @64 fputu " --\n" out-fd @64 fputs
            "    mov rax, "              out-fd @64 fputs dup Op.operand @64 out-fd @64 fputu "\n" out-fd @64 fputs
            "    push rax\n"             out-fd @64 fputs
        else dup @Op.typ OP_IF = if*
            ";;  -- if --\n"             out-fd @64 fputs
            "    pop rax\n"              out-fd @64 fputs
            "    test rax, rax\n"        out-fd @64 fputs
            "    jz addr_\n"             out-fd @64 fputs dup @Op.operand out-fd @64 fputu "\n" out-fd @64 fputs
        else dup @Op.typ OP_ELSE = if*
            ";;  -- else --\n"             out-fd @64 fputs
            "    jmp addr_\n"            out-fd @64 fputs dup @Op.operand out-fd @64 fputu "\n" out-fd @64 fputs
        else dup @Op.typ OP_END = if*
            ";;  -- end --\n" out-fd @64 fputs
            "    jmp addr_\n" out-fd @64 fputs dup @Op.operand out-fd @64 fputu "\n" out-fd @64 fputs
        else dup @Op.typ OP_INTRINSIC = if*
            assert
                "Exhaustive handling of intrinsics in parse-file-path"
                COUNT_INTRINSICS 42 =
            end
            dup @Op.operand INTRINSIC_PLUS = if
                ";;  -- plus --\n"       out-fd @64 fputs
                "    pop rax\n"          out-fd @64 fputs
                "    pop rbx\n"          out-fd @64 fputs
                "    add rax, rbx\n"     out-fd @64 fputs
                "    push rax\n"         out-fd @64 fputs
            else dup @Op.operand INTRINSIC_MINUS = if*
                ";;  -- minus --\n"      out-fd @64 fputs
                "    pop rax\n"          out-fd @64 fputs
                "    pop rbx\n"          out-fd @64 fputs
                "    sub rbx, rax\n"     out-fd @64 fputs
                "    push rbx\n"         out-fd @64 fputs
            else dup @Op.operand INTRINSIC_MUL = if*
                ";;  -- mul --\n"        out-fd @64 fputs
                "    pop rax\n"          out-fd @64 fputs
                "    pop rbx\n"          out-fd @64 fputs
                "    mul rbx\n"          out-fd @64 fputs
                "    push rax\n"         out-fd @64 fputs
            else dup @Op.operand INTRINSIC_DIVMOD = if*
                ";;  -- divmod --\n"     out-fd @64 fputs
                "    xor rdx, rdx\n"     out-fd @64 fputs
                "    pop rbx\n"          out-fd @64 fputs
                "    pop rax\n"          out-fd @64 fputs
                "    div rbx\n"          out-fd @64 fputs
                "    push rax\n"         out-fd @64 fputs
                "    push rdx\n"         out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SHR = if*
                ";;  -- shr --\n"        out-fd @64 fputs
                "    pop rcx\n"          out-fd @64 fputs
                "    pop rbx\n"          out-fd @64 fputs
                "    shr rbx, cl\n"      out-fd @64 fputs
                "    push rbx\n"         out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SHL = if*
                ";;  -- shl --\n"        out-fd @64 fputs
                "    pop rcx\n"          out-fd @64 fputs
                "    pop rbx\n"          out-fd @64 fputs
                "    shl rbx, cl\n"      out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_OR = if*
                ";;  -- or --\n"                 out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    or rbx, rax\n"              out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_AND = if*
                ";;  -- and --\n"                out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    and rbx, rax\n"             out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_NOT = if*
                ";;  -- not --\n"                out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    not rax\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_PRINT = if*
                ";;  -- print --\n"              out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    call print\n"               out-fd @64 fputs
            else dup @Op.operand INTRINSIC_EQ = if*
                ";;  -- equal -- \n"             out-fd @64 fputs
                "    mov rcx, 0\n"               out-fd @64 fputs
                "    mov rdx, 1\n"               out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    cmp rax, rbx\n"             out-fd @64 fputs
                "    cmove rcx, rdx\n"           out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_GT = if*
                ";;  -- gt --\n"                 out-fd @64 fputs
                "    mov rcx, 0\n"               out-fd @64 fputs
                "    mov rdx, 1\n"               out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    cmp rax, rbx\n"             out-fd @64 fputs
                "    cmovg rcx, rdx\n"           out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_LT = if*
                ";;  -- gt --\n"                 out-fd @64 fputs
                "    mov rcx, 0\n"               out-fd @64 fputs
                "    mov rdx, 1\n"               out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    cmp rax, rbx\n"             out-fd @64 fputs
                "    cmovl rcx, rdx\n"           out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_GE = if*
                ";;  -- gt --\n"                 out-fd @64 fputs
                "    mov rcx, 0\n"               out-fd @64 fputs
                "    mov rdx, 1\n"               out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    cmp rax, rbx\n"             out-fd @64 fputs
                "    cmovge rcx, rdx\n"          out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_LE = if*
                ";;  -- gt --\n"                 out-fd @64 fputs
                "    mov rcx, 0\n"               out-fd @64 fputs
                "    mov rdx, 1\n"               out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    cmp rax, rbx\n"             out-fd @64 fputs
                "    cmovle rcx, rdx\n"          out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_NE = if*
                ";;  -- ne --\n"                 out-fd @64 fputs
                "    mov rcx, 0\n"               out-fd @64 fputs
                "    mov rdx, 1\n"               out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    cmp rax, rbx\n"             out-fd @64 fputs
                "    cmovne rcx, rdx\n"          out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_DUP = if*
                ";;  -- dup -- \n"               out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SWAP = if*
                ";;  -- swap --\n"               out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_DROP = if*
                ";;  -- drop --\n"               out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
            else dup @Op.operand INTRINSIC_OVER = if*
                ";;  -- over --\n"               out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_ROT = if*
                ";;  -- rot --\n"                out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    pop rcx\n"                  out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
                "    push rcx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_LOAD8 = if*
                ";;  -- load --\n"               out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    xor rbx, rbx\n"             out-fd @64 fputs
                "    mov bl, [rax]\n"            out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_STORE8 = if*
                ";;  -- store --\n"              out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    mov [rax], bl\n"            out-fd @64 fputs
            else dup @Op.operand INTRINSIC_LOAD16 = if*
                ";;  -- load16 --\n"             out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    xor rbx, rbx\n"             out-fd @64 fputs
                "    mov rbx, [rax]\n"           out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_STORE16 = if*
                ";;  -- store16 --\n"            out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    mov [rax], rbx\n"           out-fd @64 fputs
            else dup @Op.operand INTRINSIC_LOAD32 = if*
                ";;  -- load32 --\n"             out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    xor rbx, rbx\n"             out-fd @64 fputs
                "    mov rbx, [rax]\n"           out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_STORE32 = if*
                ";;  -- store32 --\n"            out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    mov [rax], rbx\n"           out-fd @64 fputs
            else dup @Op.operand INTRINSIC_LOAD64 = if*
                ";;  -- load64 --\n"             out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    xor rbx, rbx\n"             out-fd @64 fputs
                "    mov rbx, [rax]\n"           out-fd @64 fputs
                "    push rbx\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_STORE64 = if*
                ";;  -- store64 --\n"            out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rbx\n"                  out-fd @64 fputs
                "    mov [rax], rbx\n"           out-fd @64 fputs
            else dup @Op.operand INTRINSIC_CAST_PTR = if*
                ";;  -- cast(ptr) --\n"          out-fd @64 fputs
            else dup @Op.operand INTRINSIC_CAST_INT = if*
                ";;  -- cast(int) --\n"          out-fd @64 fputs
            else dup @Op.operand INTRINSIC_CAST_BOOL = if*
                ";;  -- cast(bool) --\n"          out-fd @64 fputs
            else dup @Op.operand INTRINSIC_ARGC = if*
                ";;  -- argc --\n"               out-fd @64 fputs
                "    mov rax, [args_ptr]\n"      out-fd @64 fputs
                "    mov rax, [rax]\n"           out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_ARGV = if*
                ";;  -- argv --\n"               out-fd @64 fputs
                "    mov rax, [args_ptr]\n"      out-fd @64 fputs
                "    add rax, 8\n"               out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs 
            else dup @Op.operand INTRINSIC_HERE = if*
                    here eputs ": TODO: `here` is not implemented yet" eputs
            else dup @Op.operand INTRINSIC_SYSCALL0 = if*
                ";;  -- syscall0 --\n"           out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SYSCALL1 = if*
                ";;  -- syscall1 --\n"           out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SYSCALL2 = if*
                ";;  -- syscall2 -- \n"          out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    pop rsi\n"                  out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SYSCALL3 = if*
                ";;  -- syscall3 --\n"           out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    pop rsi\n"                  out-fd @64 fputs
                "    pop rdx\n"                  out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SYSCALL4 = if*
                ";;  -- syscall4 --\n"           out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    pop rsi\n"                  out-fd @64 fputs
                "    pop rdx\n"                  out-fd @64 fputs
                "    pop r10\n"                  out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SYSCALL5 = if*
                ";;  -- syscall5 --\n"           out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    pop rsi\n"                  out-fd @64 fputs
                "    pop rdx\n"                  out-fd @64 fputs
                "    pop r10\n"                  out-fd @64 fputs
                "    pop r8\n"                   out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else dup @Op.operand INTRINSIC_SYSCALL6 = if*
                ";;  -- syscall6 --\n"           out-fd @64 fputs
                "    pop rax\n"                  out-fd @64 fputs
                "    pop rdi\n"                  out-fd @64 fputs
                "    pop rsi\n"                  out-fd @64 fputs
                "    pop rdx\n"                  out-fd @64 fputs
                "    pop r10\n"                  out-fd @64 fputs
                "    pop r8\n"                   out-fd @64 fputs
                "    pop r9\n"                   out-fd @64 fputs
                "    syscall\n"                  out-fd @64 fputs
                "    push rax\n"                 out-fd @64 fputs
            else
                here eputs ": unreachable\n" eputs
                1 exit
            end
        else 
            here eputs ": unreachable\n" eputs 
            1 exit
        end
        drop
        1 +
    end drop

    "addr_"              out-fd @64 fputs
    @ops-count           out-fd @64 fputu
    ":\n"              out-fd @64 fputs

    "    mov rax, 60\n"  out-fd @64 fputs
    "    mov rdi, 0\n"   out-fd @64 fputs
    "    syscall\n"      out-fd @64 fputs
    "segment .bss\n"     out-fd @64 fputs
    "args_ptr: resq 1\n" out-fd @64 fputs
    "mem: resb "         out-fd @64 fputs MEM_CAPACITY out-fd @64 fputu "\n" out-fd @64 fputs

    out-fd @64 close drop
    
    memory nasm-argv  sizeof(ptr) 4 * end
    "/usr/bin/nasm"c nasm-argv 0 8 * + !64
    "-felf64"c       nasm-argv 1 8 * + !64
    "output.asm"c    nasm-argv 2 8 * + !64
    NULL             nasm-argv 3 8 * + !64
    nasm-argv cmd_echoed
    
    memory ld-argv sizeof(ptr) 5 * end
    "/usr/bin/ld"c ld-argv 0 8 * + !64
    "-o"c          ld-argv 1 8 * + !64
    "output"c      ld-argv 2 8 * + !64
    "output.o"c    ld-argv 3 8 * + !64
    NULL           ld-argv 4 8 * + !64
    ld-argv cmd_echoed
    
    memory output-argv sizeof(ptr) 2 * end
    "./output"c output-argv 0 8 * + !64
    NULL        output-argv 1 8 * + !64
    output-argv cmd_echoed
end

const  PARSE_BLOCK_STACK_CAP 1024                            end
memory parse-block-stack-count sizeof(u64)                   end
proc  @parse-block-stack-count parse-block-stack-count @64  end
memory parse-block-stack sizeof(u64) PARSE_BLOCK_STACK_CAP * end

proc parse-block-stack-push
    @parse-block-stack-count PARSE_BLOCK_STACK_CAP >= if
        here puts ": ERROR: parse block stackoverflow\n" eputs
        1 exit
    end
    parse-block-stack @parse-block-stack-count sizeof(u64) * + !64
    parse-block-stack-count inc64 
end

proc parse-block-stack-pop
    @parse-block-stack-count 0 = if
        here puts ": ERROR: parse block stack underflow\n" eputs
        1 exit
    end
    parse-block-stack-count dec64
    parse-block-stack @parse-block-stack-count sizeof(u64) * + @64
end

proc str-starts-with // prefix-count prefix-data input-count input-data
    memory ssw-prefix sizeof(Str) end
    memory ssw-input  sizeof(Str) end
    ssw-input !Str
    ssw-prefix !Str

    ssw-prefix @Str.count
    ssw-input  @Str.count
    <= if
        0 while
            dup ssw-prefix @Str.count < if
                dup ssw-input @Str.data + @8
                over ssw-prefix @Str.data + @8
                =
            else false end
        do 1 + end
        ssw-prefix @Str.count >=
    else false end
end

proc remove-comment // output input
    memory comment sizeof(Str) end "//" comment !Str

    over 0 swap !Str.count
    2dup @Str.data swap !Str.data
    while
        dup @Str.count 0 > if
            dup comment @Str rot @Str str-starts-with lnot
        else false end
    do
        dup str-chop-one-left
        over Str.count inc64
    end
    2drop
end

proc memset // int int ptr --
    memory data sizeof(ptr) end
    data !64
    memory byte sizeof(u64) end
    byte !64
    while dup 0 > do
        byte @64 data @ptr !64
        1 -
    end
    drop
end

const Loc.file-path sizeof(Str) offset end
const Loc.row       sizeof(u64) offset end
const Loc.col       sizeof(u64) offset end
const sizeof(Loc)                reset end

const TOKEN_INT  1 offset end
const TOKEN_WORD 1 offset end
const TOKEN_STR  1 offset end
const TOKEN_CHAR 1 offset end
const COUNT_TOKENS reset  end

const Token.typ sizeof(u64) offset end
const Token.loc sizeof(Loc) offset end
const Token.text sizeof(Str) offset end
const Token.value
   sizeof(u64)
   sizeof(Str) max
   offset
end
const sizeof(Token) reset end

// Lexer structure
const Lexer.content    sizeof(Str) offset end
const Lexer.line       sizeof(Str) offset end
const Lexer.line-start sizeof(ptr) offset end
const Lexer.file-path  sizeof(Str) offset end
const Lexer.row        sizeof(u64) offset end
const sizeof(Lexer)                 reset end

proc ?str-empty
    offsetof(Str.count) +
    @64
    0 =
end

proc lexer-next-line // lexer:ptr --
    memory lexer sizeof(ptr) end
    lexer !64

    memory line sizeof(Str) end

    '\n'
    line
    lexer @ptr Lexer.content +
    str-chop-by-delim

    lexer @ptr Lexer.line + offsetof(Str.data) + @ptr
    lexer @ptr Lexer.line-start +
    !64

    lexer @ptr Lexer.line +
    line
    remove-comment

    lexer @ptr Lexer.row + inc64
end

proc lexer-next-token // token:ptr lexer:ptr -- bool
    memory lexer sizeof(ptr) end
    lexer !64
    memory token sizeof(ptr) end
    token !64

    memory word sizeof(Str) end

    lexer @ptr
    while 
        dup Lexer.line + str-trim-left

        dup Lexer.line + ?str-empty if
            dup Lexer.content + ?str-empty lnot
        else false end
    do dup lexer-next-line end

    dup Lexer.line + ?str-empty lnot if
        dup Lexer.line + @Str.data @8 '"' = if
            // String literal

            dup Lexer.line + str-chop-one-left
            '"' word rot Lexer.line + str-chop-by-delim

            word @Str token @ptr Token.value + !Str
            TOKEN_STR token @ptr Token.typ + !64
            // TODO: check if string literal was clsoed
        else dup Lexer.line + @Str.data @8 39 = if* // cannot use ' directy for some reason
            // Character literal
            dup Lexer.line + str-chop-one-left
            39 word rot Lexer.line + str-chop-by-delim

            word @Str token @ptr Token.value + !Str
            TOKEN_CHAR token @ptr Token.typ + !64
            // TODO: check if character literal was clsoed
        else
            // Word or integer

            ' '              // delim
            word             // word
            rot Lexer.line + // line
            str-chop-by-delim

            word @Str try-parse-int if
                token @ptr Token.value + !64
                TOKEN_INT token @ptr Token.typ + !64
            else
                drop // number from try-parse-int
                word @Str token @ptr Token.value + !Str
                TOKEN_WORD token @ptr Token.typ + !64
            end
        end

        sizeof(Str)
        lexer @ptr Lexer.file-path +
        token @ptr Token.loc + Loc.file-path +
        memcpy

        lexer @ptr Lexer.row + @64
        token @ptr Token.loc + Loc.row +
        !64

        word offsetof(Str.data) + @ptr
        lexer @ptr Lexer.line-start + @ptr
        -
        token @ptr Token.loc + Loc.col +
        !64
    true
    else
        drop // lexer
        false
    end
end

proc map-file // file-path-cstr -- int str
    memory file-path-cstr sizeof(ptr) end
    file-path-cstr !64

    0                   // mode
    O_RDONLY            // flags
    file-path-cstr @ptr // pathname
    AT_FDCWD            // dirfd
    openat

    dup 0 < if
      "ERROR: could not open file " eputs file-path-cstr @ptr cstr-to-str eputs "\n" eputs
      1 exit
    end

    memory fd sizeof(u64) end
    fd !64

    memory statbuf sizeof(stat) end
    statbuf fd @64 fstat 0 < if
      "ERROR: could not determine the size of file " eputs file-path-cstr @ptr cstr-to-str eputs "\n" eputs
      1 exit
    end

    memory content sizeof(Str) end
    statbuf @stat.st_size content !Str.count

    0                        // offset
    fd @64                   // fd
    MAP_PRIVATE              // flags
    PROT_READ                // prot
    content @Str.count       // length
    NULL                     // addr
    mmap
    content !Str.data

    content @Str.data cast(int) 0 < if
      "ERROR: could not memory map file " eputs file-path-cstr @ptr cstr-to-str eputs "\n" eputs
      1 exit
    end

    content @Str
end

proc lex-file // file-path-cstr --
    memory file-path-cstr sizeof(ptr) end
    file-path-cstr !64

    memory lexer sizeof(Lexer) end
    sizeof(Lexer) 0 lexer memset
    file-path-cstr @ptr map-file    lexer Lexer.content   + !Str
    file-path-cstr @ptr cstr-to-str lexer Lexer.file-path + !Str

    memory token sizeof(Token) end
    
    while token lexer lexer-next-token do
        assert 
            "Exhaustive handling of token types in lex-file"
            COUNT_TOKENS 4 =
        end

        token Token.loc + // loc
        dup Loc.file-path + @Str puts ":" puts
        dup Loc.row + @64 putu        ":" puts
        dup Loc.col + @64 putu        ":" puts
        drop // loc

        token Token.typ + @64 // token.typ
        dup TOKEN_INT = if
            "[INTEGER] " puts token Token.value + @64 putu "\n" puts
        else dup TOKEN_WORD = if*
            "[WORD] " puts token Token.value + @Str puts "\n" puts
        else dup TOKEN_STR = if*
            "[STR] \"" puts token Token.value + @Str puts "\"\n" puts
        else dup TOKEN_CHAR = if*
            "[CHAR] \'" puts token Token.value + @Str puts "\'\n" puts
        else
            here eputs ": Unreachable. Unknown token type.\n" eputs
            1 exit
        end
 
        drop // token.typ
    end
end

proc parse_file_path_cstr_into_opz // file-path-cstr 
    memory file-path-cstr sizeof(ptr) end
    file-path-cstr !64

    memory content sizeof(Str) end
    file-path-cstr @ptr map-file content !Str

    memory line_number sizeof(u64) end
    memory line-with-comment sizeof(Str) end
    memory line sizeof(Str) end
    memory word sizeof(Str) end
    memory line_start sizeof(ptr) end

    1 line_number !64
    while content @Str.count 0 > do
      '\n' line-with-comment content str-chop-by-delim
      line line-with-comment remove-comment
      line @Str.data line_start !64
      while line @Str.count 0 > do
        line str-trim-left
        ' ' word line str-chop-by-delim

        assert
            "Exhaustive handling of Op types in parse-file-path"
            COUNT_OPZ 5 = 
        end

        assert
            "Exhaustive handling of Intrinsics in parse-file-path"
            COUNT_INTRINSICS 42 =
        end

        // Intrinsics
        word @Str "+" streq if
          OP_INTRINSIC INTRINSIC_PLUS push-op
        else word @Str "-" streq if*
          OP_INTRINSIC INTRINSIC_MINUS push-op
        else word @Str "*" streq if*
          OP_INTRINSIC INTRINSIC_MUL push-op
        else word @Str "divmod" streq if*
          OP_INTRINSIC INTRINSIC_DIVMOD push-op
        else word @Str "print" streq if*
          OP_INTRINSIC INTRINSIC_PRINT push-op
        else word @Str "=" streq if*
          OP_INTRINSIC INTRINSIC_EQ push-op
        else word @Str ">" streq if*
          OP_INTRINSIC INTRINSIC_GT push-op
        else word @Str "<" streq if*
          OP_INTRINSIC INTRINSIC_LT push-op
        else word @Str ">=" streq if*
          OP_INTRINSIC INTRINSIC_GE push-op
        else word @Str "<=" streq if*
          OP_INTRINSIC INTRINSIC_LE push-op
        else word @Str "!=" streq if*
          OP_INTRINSIC INTRINSIC_NE push-op
        else word @Str "shr" streq if*
          OP_INTRINSIC INTRINSIC_SHR push-op
        else word @Str "shl" streq if*
          OP_INTRINSIC INTRINSIC_SHL push-op
        else word @Str "or" streq if*
          OP_INTRINSIC INTRINSIC_OR push-op
        else word @Str "and" streq if*
          OP_INTRINSIC INTRINSIC_AND push-op
        else word @Str "not" streq if*
          OP_INTRINSIC INTRINSIC_NOT push-op
        else word @Str "dup" streq if*
          OP_INTRINSIC INTRINSIC_DUP push-op
        else word @Str "swap" streq if*
          OP_INTRINSIC INTRINSIC_SWAP push-op
        else word @Str "drop" streq if*
          OP_INTRINSIC INTRINSIC_DROP push-op
        else word @Str "over" streq if*
          OP_INTRINSIC INTRINSIC_OVER push-op
        else word @Str "rot" streq if*
          OP_INTRINSIC INTRINSIC_ROT push-op
        else word @Str "!8" streq if*
          OP_INTRINSIC INTRINSIC_STORE8 push-op
        else word @Str "@8" streq if*
          OP_INTRINSIC INTRINSIC_LOAD8 push-op
        else word @Str "!16" streq if*
          OP_INTRINSIC INTRINSIC_STORE16 push-op
        else word @Str "@16" streq if*
          OP_INTRINSIC INTRINSIC_LOAD16 push-op
        else word @Str "!32" streq if*
          OP_INTRINSIC INTRINSIC_STORE32 push-op
        else word @Str "@32" streq if*
          OP_INTRINSIC INTRINSIC_LOAD32 push-op
        else word @Str "!64" streq if*
          OP_INTRINSIC INTRINSIC_STORE64 push-op
        else word @Str "@64" streq if*
          OP_INTRINSIC INTRINSIC_LOAD64 push-op
        else word @Str "cast(ptr)" streq if*
          OP_INTRINSIC INTRINSIC_CAST_PTR push-op
        else word @Str "cast(int)" streq if*
          OP_INTRINSIC INTRINSIC_CAST_INT push-op
        else word @Str "cast(bool)" streq if*
          OP_INTRINSIC INTRINSIC_CAST_BOOL push-op
        else word @Str "argc" streq if*
          OP_INTRINSIC INTRINSIC_ARGC push-op
        else word @Str "argv" streq if*
          OP_INTRINSIC INTRINSIC_ARGV push-op
        else word @Str "here" streq if*
          OP_INTRINSIC INTRINSIC_HERE push-op
        else word @Str "syscall0" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL0 push-op
        else word @Str "syscall1" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL1 push-op
        else word @Str "syscall2" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL2 push-op
        else word @Str "syscall3" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL3 push-op
        else word @Str "syscall4" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL4 push-op
        else word @Str "syscall5" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL5 push-op
        else word @Str "syscall6" streq if*
          OP_INTRINSIC INTRINSIC_SYSCALL6 push-op

        // Keywords
        else word @Str "if" streq if*
          @ops-count parse-block-stack-push
          OP_IF 0 push-op
        else word @Str "else" streq if*
          @parse-block-stack-count 0 <= if
            file-path-cstr @ptr cstr-to-str eputs
            ":" puts line_number @64 putu
            ":" puts word @Str.data cast(int) line_start @64 - 1 + putu
            ": ERROR: `else` can only come after `if`\n" eputs
            1 exit
          end

          parse-block-stack-pop   // if_ip
          dup sizeof(Op) * ops +  // if_op

          dup @Op.typ OP_IF != if
            file-path-cstr @ptr cstr-to-str eputs
            ":" puts line_number @64 putu
            ":" puts word @Str.data cast(int) line_start @64 - 1 + putu
            ": ERROR: `else` can only come after `if`\n" eputs
            1 exit
          end

          @ops-count 1 + over !Op.operand

          @ops-count parse-block-stack-push
          OP_ELSE 0 push-op

          drop // if_op
          drop // if_ip
        else word @Str "end" streq if*
          @parse-block-stack-count 0 <= if
            file-path-cstr @ptr cstr-to-str eputs
            ":" puts line_number @64 putu
            ":" puts word @Str.data cast(int) line_start @64 - 1 + putu
            ": ERROR: `end` can only close `if` and `else` for now\n" eputs
            1 exit
          end

          parse-block-stack-pop // ip
          ops over sizeof(Op) * + // op

          dup @Op.typ OP_IF = if
            dup @ops-count swap !Op.operand
            OP_END @ops-count 1 + push-op
          else dup @Op.typ OP_ELSE = if*
            dup @ops-count swap !Op.operand
            OP_END @ops-count 1 + push-op
          else
            file-path-cstr @ptr cstr-to-str eputs
            ":" puts line_number @64 putu
            ":" puts word @Str.data cast(int) line_start @64 - 1 + putu
            ": ERROR: `end` can only close `if` for now\n" eputs
            1 exit
          end

          drop // op
          drop // ip
        else word @Str "include" streq if*
          here eputs ": TODO: `include` keyword is not implemented\n" eputs 1 exit
        else
          OP_PUSH_INT
          word @Str try-parse-int lnot if
            file-path-cstr @ptr cstr-to-str eputs
            ":" puts line_number @64 putu
            ":" puts word @Str.data cast(int) line_start @64 - 1 + putu
            ": ERROR: `" eputs word @Str eputs "` is unknown word\n" eputs
            1 exit
          end
          push-op
        end

      end
      line_number inc64
    end
    // TODO: parse_file_path does not clean up resources after itself
end


proc print_usage // fd -- 
    memory fd sizeof(u64) end
    fd !64

    "Usage: porth <SUBCOMMAND>\n"                                             fd @64 fputs
    "  SUBCOMMAND:\n"                                                         fd @64 fputs
    "    sim <file>     Simulate the program\n"                               fd @64 fputs
    "    com <file>     Compile the program\n"                                fd @64 fputs
    "    print <file>   Print ops of the program\n"                           fd @64 fputs
    "    help           Print this help to the stderr ane exit with 0 code\n" fd @64 fputs
end

// entrypoint of the program
proc main 
    argc 2 < if
        stderr print_usage
        here eputs ": ERROR: subcommands is not provided\n" eputs
        1 exit
    end

    1 nth_argv
    dup "com"c cstreq if
        argc 3 < if
            stderr print_usage
            "ERROR: No input file provided for the `com` subcommand" eputs
            1 exit
        end

        2 nth_argv parse_file_path_cstr_into_opz

        compile-opz
    else dup "sim"c cstreq if*
        argc 3 < if
            stderr print_usage
            "ERROR: No input file provided for the `sim` subcommand" eputs
            1 exit
        end
        2 nth_argv parse_file_path_cstr_into_opz

        simulate-opz
    else dup "print"c cstreq if*
        argc 3 < if
            stderr print_usage
            "ERROR: No input file provided for the `print` subcommand" eputs
            1 exit
        end
        
        2 nth_argv parse_file_path_cstr_into_opz

        print-opz
    else dup "lex"c cstreq if*
        argc 3 < if
            stderr print_usage
            "ERROR: not input file provided for `lex` subcommand\n" eputs
            1 exit
        end

        2 nth_argv lex-file
    else dup "help"c cstreq if*
        stdout print_usage
        0 exit
    else
        stderr print_usage
        "ERROR: unknown subcommand `" eputs dup dup cstrlen swap eputs "`\n" eputs
        1 exit
    end
    drop
end
main
